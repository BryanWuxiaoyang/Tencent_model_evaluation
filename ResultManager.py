import os
from utils import *
import json


class ResultManager:
    """
    collect and record output values generated by a model
    """
    def __init__(self, key_name: str, file_path: str, lazy_load: bool = False):
        self.key_name = key_name
        self.file_path = file_path
        self.data = {}
        self.is_loaded = False

        if not lazy_load:
            self.load_data()

    def load_data(self):
        if self.is_loaded:
            return
        file_path = self.file_path
        if os.path.exists(file_path):
            with open(file_path, "r", encoding="utf8") as f:
                data = json.load(f)
                data.update(self.data)
                self.data = data
        self.is_loaded = True

    def get(self, key):
        self.load_data()
        return self.data.get(key)

    def __iter__(self):
        self.load_data()
        return self.data.items().__iter__()

    def append(self, key, **value):
        self.data[key] = value

    def save(self, clear: bool = False):
        self.load_data()
        self.save_json(self.file_path)
        if clear:
            self.is_loaded = False
            self.data = {}

    def save_json(self, file_path: str):
        self.load_data()
        if self.file_path is not None:
            import json
            with open(file_path, "w", encoding='utf8') as f:
                json.dump(self.data, f, ensure_ascii=False)

    def save_csv(self, file_path: str):
        self.load_data()
        import csv
        f = open(file_path, "w", encoding="utf8")
        writer = csv.writer(f)

        headers = set()
        for key, value_map in self.data.items():
            for value_key in value_map.keys():
                headers.add(value_key)

        v_headers = [key for key in headers]
        v_headers.sort()
        headers = [self.key_name] + v_headers

        writer.writerow(headers)

        header_index = {}
        for idx, header in enumerate(headers):
            header_index[header] = idx

        assert header_index[self.key_name] == 0
        for key, value_map in self.data.items():
            row = [""] * len(headers)
            row[0] = key
            for value_key, value in value_map.items():
                row[header_index[value_key]] = value

            writer.writerow(row)

        f.close()


class ImageResultManager:
    """
    collect information inferred by a model which takes image as input and output different attributes
    """
    def __init__(self, index_file_path: str, image_dir: str, lazy_load: bool = False):
        self.index_manager = ResultManager(key_name="image_path", file_path=index_file_path, lazy_load=lazy_load)
        self.image_dir = create_dir(image_dir)

    def __iter__(self, require_image: bool = True):
        import cv2
        for image_path, value_map in self.index_manager:
            if require_image:
                image = cv2.imread(image_path, cv2.IMREAD_COLOR)
                yield image_path, value_map, image
            else:
                yield image_path, value_map

    def append(self, image, image_name, **value):
        import cv2

        write_path = os.path.join(self.image_dir, os.path.basename(image_name))
        write_path = os.path.abspath(write_path)
        if not os.path.exists(write_path):
            # print("saving image: ", write_path)
            cv2.imwrite(write_path, image)
        # print("write: ", write_path)
        self.index_manager.append(write_path, **value)

    def save(self, clear: bool = False):
        self.index_manager.save(clear=clear)

    def get(self, image_name, require_image: bool = False):
        import cv2

        image_path = os.path.abspath(os.path.join(self.image_dir, os.path.basename(image_name)))

        value = self.index_manager.get(image_path)
        if require_image:
            image = cv2.imread(image_path, cv2.IMREAD_COLOR) if os.path.exists(image_path) else None
            return value, image
        else:
            return value


